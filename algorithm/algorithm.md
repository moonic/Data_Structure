# algorithm

* 基础编程模型
 * 程序是对算法精确、优雅和完全的描述；
 * 可以通过运行程序来学习算法的各种性质；
 * 可以在应用程序中直接使用这些算法。

## 查找

* 二分查找  
  * 接受一个白名单文件（一列整数）作为参数，并会过滤掉标准输入中的所有存在于白名单中的条目，
  * 仅将不在白名单上的整数打印到标准输出中 它在 rank() 静态方法中实现了二分查找算法并高效地完成了这个任务。
  * 白名单过滤
    * 如果可能，我们的测试用例都会通过模拟实际情况来展示当前算法的必要性。这里该过程被称为白名单过滤。
   可以想象一家信用卡公司，它需要检查客户的交易账号是否有效。为此，
      * 它需要：
        - 将客户的账号保存在一个文件中，我们称它为白名单；
        - 从标准输入中得到每笔交易的账号；
        - 使用这个测试用例在标准输出中打印所有与任何客户无关的账号，公司很可能拒绝此类交易


## 排序
>排序就是将一组对象按照某种逻辑顺序重新排列的过程。比如，信用卡账单中的交易是按照日
期排序的——这种排序很可能使用了某种排序算法

- 对排序算法的分析将有助于你全面理解本书中比较算法性能的方法；
- 类似的技术也能有效解决其他类型的问题；
- 排序算法常常是我们解决其他问题的第一步。

* 插入排序
  * 人们整理桥牌的方法是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。
  * 在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。这种算法叫做插入排序，
  * 与选择排序一样，当前索引左边的所有元素都是有序的，但它们的最终位置还不确定，为了给更小的元素腾出空间，它们可能会被移动。
  * 但是当索引到达数组的右端时，数组排序就完成了。和选择排序不同的是，插入排序所需的时间取决于输入中元素的初始顺序。
    * 例如，对一个很大且其中的元素已经有序（或接近有序）的数组进行排序将会比对随机顺序的数组或是逆序数组进行排序要快得多。
* 命题 B
  * 对于随机排列的长度为 N 且主键不重复的数组，平均情况下插入排序需要～ N 2 /4 次比较以及～ N 2 /4 次交换
  * 最坏情况下需要～ N 2 /2 次比较和～ N 2 /2 次交换，最好情况下需要 N-1次比较和 0 次交换。

* 证明
  * 和命题 A 一样，通过一个 N × N 的轨迹表可以很容易就得到交换和比较的次数。最坏情况下对角线之下所有的元素都需要移动位置，最好情况下都不需要。对于随机排列的数组，在平均情况下每个元素都可能向后移动半个数组的长度，因此交换总数是对角线之下的元素总数的二分之一
  * 比较的总次数是交换的次数加上一个额外的项，该项为 N 减去被插入的元素正好是已知的最小元素的次数。在最坏情况下（逆序数组），这一项相对于总数可以忽略不计；在最好情况下（数组已经有序），这一项等于 N -1。

* 倒置指的是数组中的两个顺序颠倒的元素。比
如 E X A M P L E 中有 11 对倒置：E-A、 X-A、 X-M、 X-P、 X-L、 X-E、 M-L、 M-E、 P-L、 P-E以及 L-E。如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是部分有序的。
  * 下面是几种典型的部分有序的数组：
   * 数组中每个元素距离它的最终位置都不远；
   * 一个有序的大数组接一个小数组；
   * 数组中只有几个元素的位置不正确。
  * 插入排序对这样的数组很有效，而选择排序则不然。事实上，当倒置的数量很少时，插入排序很可能比本章中的其他任何算法都要快。
  
* 排序算法的可视化
图示来帮助我们说明排序算法的性质 并没有使用字母、数字或是单词这样的键值来跟踪排序的进程，而使用了棒状图，并以它们的高矮来排序。这种表示方法的好处是能够使排序过程一目了然。
 * StdDraw 库画出一张可视轨迹图并不比追踪一次算法的运行轨迹难多少。将Double 值排序，并在适当的时候指示算法调
用 show() 方法（和追踪算法的轨迹时一样），然后开发一个使用 StdDraw 来绘制棒状图而不是打印结果的 show() 方法。最复杂的部分是设置 y轴的比例以使轨迹的线条符合预期的顺序。请通过练习 2.1.18 来更好地理解可视轨迹图的价值和使用。
  * 将轨迹变成动画，理解起来就更加简单，这样可以看到动态演化到有序状态的过程。产生轨迹动画的过程本质上和上一段所描述的相同，但不需要担心 y 轴的问题（只需每次擦除窗口中的内容并重绘棒状图即可）
 
* 比较两个算法：
  * 实现并调试它们；
  * 分析它们的基本性质；
  * 对它们的相对性能作出猜想；
  * 用实验验证我们的猜想。
* 对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数。

* 希尔排序
   * 基于插入排序的快速的排序算法。对于大规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组
    的一端移动到另一端。
    * 例如，如果主键最小的元素正好在数组的尽头，要将它挪到正确的位置就需要 N -1 次移动。希尔排序为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。
    * 希尔排序的思想是使数组中任意间隔为 h 的元素都是有序的。这样的数组被称为 h 有序数组。换句话说，一个 h 有序数组就是 h 个互相独立的有序数组编织在一起组成的一个数组（见图 2.1.2）在进行排序时，如果 h 很大，我们就能将元素移动到很远的地方，为实现更小的 h 有序创造方便。对于任意以 1 结尾的 h 序列，将数组排序。
    * ，如果 h 很大，我们就能将元素移动到很远的地方，为实现更小的 h 有序创造方便。用
这种方式，对于任意以1结尾的h序列，能够将数组排序这就是希尔排序使用了序列 1/2（3 k -1），从 N /3 开始递减至 1。我们把这个序列称为递增序列。它的递增序列，另一种方式是将递增序列存储在一个数组中。
    * 实现希尔排序的一种方法是对于每个 h，用插入排序将 h 个子数组独立地排序。但因为子数组
是相互独立的，一个更简单的方法是在 h- 子数组中将每个元素交换到比它大的元素之前去（将比它
大的元素向右移动一格）。只需要在插入排序的代码中将移动元素的距离由 1 改为 h 即可。这样，希
尔排序的实现就转化为了一个类似于插入排序但使用不同增量的过程。

* 归并排序
  * 将二个有序的数组合成更大的有序数组 递归的分成二个半分别排序然还归并排序 归并排序最好的特性能保证 需要的额外空间N成正比 
  * 原地归并的抽象方法
  * 将不同的有序数组归并到第三个数组中 二个数组的元素实现流量Comparable接口 创建一个适当大小的数组然后将数组从小到大的放到数组中
  当归并将大数组排序的时候 需要多次归并 在每个归并创造新数组会带来问题 原地归并的方法不需要创造额外的空间
  原地归并抽象化有班助的 对应的方法签名 
## 查　　找
> 高效检索这些信息的能力是处理它们的重要前提。
数据字典： 符号表有时被称为字典，类似于那本将单词的释义按照字母顺序排列起来的历史悠久的参考书。
在英语字典里，键就是单词，值就是单词对应的定义、发音和词源。符号表有时又叫做索引，即书
本最后将术语按照字母顺序列出以方便查找的那部分。在一本书的索引中，键就是术语，而值就是
书中该术语出现的所有页码。

* 符号表
  * 符号表是一种存储键值对的数据结构，支持两种操作：插入（put），即将一组新的键值
对存入表中；查找（get），即根据给定的键得到相应的值。
  * 字典 找出单词的释义 单词 释义
  * 图书索引 找出相关的页码 术语 一串页码
  * 文件共享 找到歌曲的下载地址 歌曲名 计算机 ID
  * 账户管理 处理交易 账户号码 交易详情
  * 网络搜索 找出相关网页 关键字 网页名称
  * 编译器 找出符号的类型和值 变量名 类型和值
  
* 泛型
  * 设计方法时我们没有指定处理对象的类型，而是使用了泛型。对于符号表，我们通过明确地指定查找时键和值的类型来区分它们的不同角色，用 Comparable 的对象来扩展典型的用例，这也会为数据类型带来许多新的方法。
