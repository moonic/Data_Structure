# algorithm

* 基础编程模型
 * 程序是对算法精确、优雅和完全的描述；
 * 可以通过运行程序来学习算法的各种性质；
 * 可以在应用程序中直接使用这些算法。

## 查找

* 二分查找  
  * 接受一个白名单文件（一列整数）作为参数，并会过滤掉标准输入中的所有存在于白名单中的条目，
  * 仅将不在白名单上的整数打印到标准输出中 它在 rank() 静态方法中实现了二分查找算法并高效地完成了这个任务。
  * 白名单过滤
    * 如果可能，我们的测试用例都会通过模拟实际情况来展示当前算法的必要性。这里该过程被称为白名单过滤。
   可以想象一家信用卡公司，它需要检查客户的交易账号是否有效。为此，
      * 它需要：
        - 将客户的账号保存在一个文件中，我们称它为白名单；
        - 从标准输入中得到每笔交易的账号；
        - 使用这个测试用例在标准输出中打印所有与任何客户无关的账号，公司很可能拒绝此类交易


## 排序
>排序就是将一组对象按照某种逻辑顺序重新排列的过程。比如，信用卡账单中的交易是按照日
期排序的——这种排序很可能使用了某种排序算法

- 对排序算法的分析将有助于你全面理解本书中比较算法性能的方法；
- 类似的技术也能有效解决其他类型的问题；
- 排序算法常常是我们解决其他问题的第一步。

* 插入排序
  * 人们整理桥牌的方法是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。
  * 在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。这种算法叫做插入排序，
  * 与选择排序一样，当前索引左边的所有元素都是有序的，但它们的最终位置还不确定，为了给更小的元素腾出空间，它们可能会被移动。
  * 但是当索引到达数组的右端时，数组排序就完成了。和选择排序不同的是，插入排序所需的时间取决于输入中元素的初始顺序。
    * 例如，对一个很大且其中的元素已经有序（或接近有序）的数组进行排序将会比对随机顺序的数组或是逆序数组进行排序要快得多。
* 命题 B
  * 对于随机排列的长度为 N 且主键不重复的数组，平均情况下插入排序需要～ N 2 /4 次比较以及～ N 2 /4 次交换
  * 最坏情况下需要～ N 2 /2 次比较和～ N 2 /2 次交换，最好情况下需要 N-1次比较和 0 次交换。

* 证明
  * 和命题 A 一样，通过一个 N × N 的轨迹表可以很容易就得到交换和比较的次数。最坏情况下对角线之下所有的元素都需要移动位置，最好情况下都不需要。对于随机排列的数组，在平均情况下每个元素都可能向后移动半个数组的长度，因此交换总数是对角线之下的元素总数的二分之一
  * 比较的总次数是交换的次数加上一个额外的项，该项为 N 减去被插入的元素正好是已知的最小元素的次数。在最坏情况下（逆序数组），这一项相对于总数可以忽略不计；在最好情况下（数组已经有序），这一项等于 N -1。

* 倒置指的是数组中的两个顺序颠倒的元素。比
如 E X A M P L E 中有 11 对倒置：E-A、 X-A、 X-M、 X-P、 X-L、 X-E、 M-L、 M-E、 P-L、 P-E以及 L-E。如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是部分有序的。
  * 下面是几种典型的部分有序的数组：
   * 数组中每个元素距离它的最终位置都不远；
   * 一个有序的大数组接一个小数组；
   * 数组中只有几个元素的位置不正确。
  * 插入排序对这样的数组很有效，而选择排序则不然。事实上，当倒置的数量很少时，插入排序很可能比本章中的其他任何算法都要快。
  
* 排序算法的可视化
图示来帮助我们说明排序算法的性质 并没有使用字母、数字或是单词这样的键值来跟踪排序的进程，而使用了棒状图，并以它们的高矮来排序。这种表示方法的好处是能够使排序过程一目了然。
 * StdDraw 库画出一张可视轨迹图并不比追踪一次算法的运行轨迹难多少。将Double 值排序，并在适当的时候指示算法调
用 show() 方法（和追踪算法的轨迹时一样），然后开发一个使用 StdDraw 来绘制棒状图而不是打印结果的 show() 方法。最复杂的部分是设置 y轴的比例以使轨迹的线条符合预期的顺序。请通过练习 2.1.18 来更好地理解可视轨迹图的价值和使用。
  * 将轨迹变成动画，理解起来就更加简单，这样可以看到动态演化到有序状态的过程。产生轨迹动画的过程本质上和上一段所描述的相同，但不需要担心 y 轴的问题（只需每次擦除窗口中的内容并重绘棒状图即可）
 
* 比较两个算法：
  * 实现并调试它们；
  * 分析它们的基本性质；
  * 对它们的相对性能作出猜想；
  * 用实验验证我们的猜想。
* 对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数。

* 希尔排序
   * 基于插入排序的快速的排序算法。对于大规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组
    的一端移动到另一端。
    * 例如，如果主键最小的元素正好在数组的尽头，要将它挪到正确的位置就需要 N -1 次移动。希尔排序为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。
    * 希尔排序的思想是使数组中任意间隔为 h 的元素都是有序的。这样的数组被称为 h 有序数组。换句话说，一个 h 有序数组就是 h 个互相独立的有序数组编织在一起组成的一个数组（见图 2.1.2）在进行排序时，如果 h 很大，我们就能将元素移动到很远的地方，为实现更小的 h 有序创造方便。对于任意以 1 结尾的 h 序列，将数组排序。
    * 如果 h 很大，我们就能将元素移动到很远的地方，为实现更小的 h 有序创造方便。用
这种方式，对于任意以1结尾的h序列，能够将数组排序这就是希尔排序使用了序列 1/2（3 k -1），从 N /3 开始递减至 1。我们把这个序列称为递增序列。它的递增序列，另一种方式是将递增序列存储在一个数组中。
    * 实现希尔排序的一种方法是对于每个 h，用插入排序将 h 个子数组独立地排序。但因为子数组
是相互独立的，一个更简单的方法是在 h- 子数组中将每个元素交换到比它大的元素之前去（将比它
大的元素向右移动一格）。只需要在插入排序的代码中将移动元素的距离由 1 改为 h 即可。这样，希
尔排序的实现就转化为了一个类似于插入排序但使用不同增量的过程。

